{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/프로그래밍","result":{"pageContext":{"currentCategory":"프로그래밍","categories":["All","프로그래밍","kafka","AWS"],"edges":[{"node":{"id":"c4bab96f-c4a8-58d1-967a-27b1484e5152","excerpt":"1. IoC(Inversion of Control)란? 의존성 관리를 외부에 하여 객체의 생성과 관리를 제어하는 개발 패턴 2. 누가? 왜? 누구한테 위임하는가? 주로 프레임 워크에 위임합니다. 대표적으로 Spring 프로레임워크라고 볼 수 있겠습니다. 왜 위임하는가? 개인적으로 생각하는 위임하는 주요 장점중 하나는 개발자가 비즈니스 로직에 집중할 수 있다는 것입니다. 그렇다면,  정도로 보면 되겠네요. 3. 예시 DI에서 활용했던 코드를 사용해서 탐구해보겠습니다. 일반적으로 개발자가 객체를 생성관리 한다면 다음과 같을 것입니다. 그렇다면, 객체생성을 프레임워크에 위임하다고 하는데 그러한 패턴을 코드로 우선 보겠습니다. 란 객체에게 의 을 달라고 하네요 🤔\n그런데 여기서 중요한 부분은 확실하게 를 사용하지 않은것으로 봐서는 객체 생성을 프레임워크에 위임한 것으로 볼 수 있습니다. 🚫그런데 실행했더니  에러가 발생하네요 🤔 Spring 의 마법을 보기위해서 무언가 설정이 더 필요한가…","fields":{"slug":"/what-is-di/2023-05-16-Ioc/"},"frontmatter":{"categories":"프로그래밍","title":"도대체 IOC?","date":"May 17, 2023"}},"next":{"fields":{"slug":"/what-is-di/2023-05-18-AOP/"}},"previous":null},{"node":{"id":"aa2ce8cb-df91-57d7-84fc-f64be0a8a64c","excerpt":"1. AOP(Aspect-Oriented Programming)? 관점지향 프로그래밍 : 관점 기반의 모듈화와 코드 분리를 위한 프로그래밍 패러다임 난해합니다 다양한 정보를 탐색해봐야할것 같다. AOP(Aspect-Oriented Programming)에서 Aspect 는 특정 동작이나 기능을 캡슐화하는 횡단 관심사의 모듈식 단위를 말합니다.\n측면은 로깅, 오류 처리 또는 보안과 같이 시스템의 여러 모듈 또는 구성 요소에 걸쳐 차단되는 문제를 분리하고 캡슐화하는 데 사용됩니다.\n이들은 프로그램의 핵심 비즈니스 로직과 별도로 이러한 교차 관심사를 모듈화하고 관리할 수 있는 방법을 제공합니다. AOP는 단지 새로운 프로그래밍 패러다임이라는 점에 유의해야 합니다. 어떤 식으로든 OOP를 대체하지는 않습니다. 오히려 모듈성을 달성하고 코드 혼란을 줄이는 또 다른 방법을 제공하여 OOP를 보완합니다.\nAOP에서 aspect는 관심의 모듈화로 정의될 수 있다. 따라서 이러한 프로그래밍 스타일…","fields":{"slug":"/what-is-di/2023-05-18-AOP/"},"frontmatter":{"categories":"프로그래밍","title":"도대체 AOP?","date":"May 17, 2023"}},"next":{"fields":{"slug":"/what-is-di/2023-05-15-DI/"}},"previous":{"fields":{"slug":"/what-is-di/2023-05-16-Ioc/"}}},{"node":{"id":"ebe7e6ff-db68-5073-a74b-6b51fc3fcd5e","excerpt":"1. DI(Dependency Injection)란? 의존성 관리를 위해 사용되는 디자인 패턴입니다. DI의 핵심 아이디어는 “제어의 역전(Inversion of Control)“입니다. 일반적으로 객체는 자신이 사용할 의존성을 직접 생성하거나 찾아내는 책임을 갖고 있습니다. 하지만 DI에서는 객체는 의존성을 요청하기 위해 컨테이너 또는 프레임워크에 의존합니다. 이렇게 함으로써 객체는 자신이 사용할 의존성을 외부에서 제공받게 되고, 의존성의 생성과 관리는 외부에 됩니다. DI를 통해 객체 간의 결합도를 낮출 수 있으며, 유닛 테스트 작성과 코드 재사용을 쉽게 할 수 있습니다. 또한 DI 컨테이너를 사용하면 의존성의 라이프사이클 관리와 의존성 간의 관계 설정을 자동화할 수 있습니다. DI 프레임워크로는 Spring, Nest 등이 있습니다. 좋은 DI 설계는 모듈화와 확장성을 개선하며, 코드를 더 테스트 가능하고 유지보수하기 쉽게 만들어줍니다. 2. 예시를 통해 알아보는 DI 장점.…","fields":{"slug":"/what-is-di/2023-05-15-DI/"},"frontmatter":{"categories":"프로그래밍","title":"도대체 DI?","date":"May 16, 2023"}},"next":{"fields":{"slug":"/kafka/2021-03-14-what-is-kafka-connect/"}},"previous":{"fields":{"slug":"/what-is-di/2023-05-18-AOP/"}}},{"node":{"id":"c0943791-cd33-591c-9f14-fce7e30e8424","excerpt":"CSRF(사이트 간 요청 위조(Cross-Site Request Forgery)? 웹 애플리케이션 취약점 중 하나로 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해서 특정 웹페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법이다. 2008년에 발생한 옥션의 개인정보 유출 사건에서도 관리자 계정을 탈취하는 데 이 방법이 사용되었다. 공격의 난이도가 높지 않아 흔히 사용된다. -나무위키- 사례 2006 년 Netflix 웹사이트에는 CSRF에 대한 수많은 취약점이 있었습니다. 이 취약점으로 인해 공격자는 피해자의 대여 대기열에 DVD를 추가하거나, 계정의 배송 주소를 변경하거나, 계정을 완전히 손상시키기 위해 피해자의 로그인 자격 증명을 변경하는 등의 작업을 수행할 수 있었습니다. ING Direct 의 온라인 뱅킹 웹 애플리케이션은 불법 자금 이체를 허용하는 CSRF 공격에 취약했습니다. 인기 동영상 웹사이트 YouTube 도 2008년에 C…","fields":{"slug":"/security/2022-01-29-csrf/"},"frontmatter":{"categories":"프로그래밍","title":"CSRF(Cross-Site Request Forgery)","date":"January 31, 2022"}},"next":{"fields":{"slug":"/security/2022-01-29-xss/"}},"previous":{"fields":{"slug":"/kafka/2021-03-14-what-is-kafka-connect/"}}},{"node":{"id":"c35cd220-5465-510a-8621-c07649066c99","excerpt":"XSS? XSS(Cross-site Scripting)란 SQL injection과 함께 웹 상에서 가장 기초적인 취약점 공격 방법의 일종으로,\n악의적인 사용자가 공격하려는 사이트에 스크립트를 넣는 기법을 말한다.\n공격에 성공하면 사이트에 접속한 사용자는 삽입된 코드를 실행하게 되며,\n보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등의 민감한 정보를 탈취한다. 공격방법 Stored XSS Stored XSS는 사이트 게시판이나 댓글, 닉네임 등 스크립트가 서버에 저장되어 실행되는 방식 Reflected XSS Reflected XSS는 보통 URL 파라미터(특히 GET 방식)에 스크립트를 넣어 서버에 저장하지 않고 그 즉시 스크립트를 만드는 방식 대부분은 Stored XSS라고 생각하면 된다. Reflected XSS의 경우 브라우저 자체에서 차단하는 경우가 많아 상대적으로 공격을 성공시키기 어렵다. -나무위키- 대응방법 문자입력을 작성한 그대로 입력하지 않는다 문자를 필…","fields":{"slug":"/security/2022-01-29-xss/"},"frontmatter":{"categories":"프로그래밍","title":"XSS(Cross-site Scripting)","date":"January 17, 2022"}},"next":{"fields":{"slug":"/kafka/2022-01-11-kafka-debezium-cdc/"}},"previous":{"fields":{"slug":"/security/2022-01-29-csrf/"}}},{"node":{"id":"cb810cca-6de7-5d1e-a9bd-cde3bcffe08b","excerpt":"학습목적으로 작성되어 생략된 내용과 다소 부적확한 내용이 있을 수 있습니다. 다루는 내용 @Entity, Jpa 연관관계, 편의메소드, @Embedded , @Embeddable 예제로 사용해볼 관계도  테이블 과  테이블이 있습니다.\n이때 는 여러개 의 을 작성 할 수 있습니다. 위의 테이블 구조로는 가 작성한 이 어떤것 인지 알수 없습니다. 그래서 이때 relation id 를 둘중 하나의 테이블에 저장 해두어야 합니다.  한명의  가 여러개의  를 가질 수 있으므로,  테이블에 관계 ID를 저장하도록 변경합니다.\n 테이블에  컬럼은  테이블의 고유 입니다. 데이터 User 테이블 id name password 1 name1 pass1 2 name2 pass2 3 name3 pass3 Post 테이블 |id|user_id|title|contents|\n|------|---|---|\n|1|3|제목 123|내용|\n|1|3|제목 748|내용|\n|2|1|제목 189|내용|\n|3|2|제목…","fields":{"slug":"/java/2021-11-21-jpa-1/"},"frontmatter":{"categories":"프로그래밍","title":"JPA - 학습하기","date":"November 21, 2021"}},"next":{"fields":{"slug":"/java/2021-11-12-builder-pattern/"}},"previous":{"fields":{"slug":"/post/2021-12-01-망분리/"}}},{"node":{"id":"5fd46c50-4398-58a9-b01e-f688869e720c","excerpt":"참조블로그 : https://asfirstalways.tistory.com/350 빌더 패턴 한번에 인스턴스를 생성하고 싶은데 생성자 인자가 너무 많을때 혹은 기본 생성자로 인스턴스를 만들고 setter 로 점진적으로 값을 주입시킬때 이럴때 빌더 패턴을 사용하면 장점이 있습니다. 빌더 패턴을 사용하지 않은 예 생성자 생성 인자가 너무 많다보니, 순차적으로 뭐가 들어가는지도 헷갈리기 시작합니다. 혹여나 실수로 위치를 다르게 넣을 수 도 있을것 같습니다. 빌더 패턴 적용 예 빌더 패턴을 사용하면 많은 생성자 인자를 명시적으로 맵핑 할 수 있는 장점이 있고, 기본 생성자를 만들고 로 순차적으로 맵핑하는 것보다\n한번에 인스턴스를 생성 할 수있습니다. 한번에 그리고 명시적으로 파라미터를 맵핑 할 수 있는 장점이 있는 빌더 패턴을 알아보았습니다.","fields":{"slug":"/java/2021-11-12-builder-pattern/"},"frontmatter":{"categories":"프로그래밍","title":"빌더 패턴","date":"November 12, 2021"}},"next":{"fields":{"slug":"/post/2021-11-10-정적-메소드-팩토리/"}},"previous":{"fields":{"slug":"/java/2021-11-21-jpa-1/"}}},{"node":{"id":"bfbf2706-d0a7-514d-a84f-e55a7f855039","excerpt":"정적 메소드 팩토리 정적 메소드 팩토리를 사용하면, 의미있는 이름의 생성자를 제공 할 수 있는 장점이 있습니다. 참조 글 baeldung.com/java-constructors-vs-static-factory-methods 1.생성자에는 의미 있는 이름 이 없으므로 항상 언어에서 부과하는 표준 명명 규칙으로 제한됩니다. 정적 팩토리 메소드는 의미 있는 이름을 가질 수 있으므로 그들이 하는 일을 명시적으로 전달합니다. 2.정적 팩토리 메서드는 메서드, 하위 유형 및 기본 형식을 구현하는 동일한 유형을 반환할 수 있으므로 보다 유연한 반환 유형 범위를 제공합니다. 3.정적 팩토리 메서드는 완전히 초기화된 인스턴스를 미리 구성하는 데 필요한 모든 논리를 캡슐화 할 수 있으므로 생성자에서 이 추가 논리를 이동하는 데 사용할 수 있습니다. 이것은 생성자가 필드를 초기화하는 것 이외의 추가 작업 을 수행하는 것을 방지 합니다. 4.정적 팩토리 메소드는 제어된 인스턴스 메소드 일 수 있으며 싱…","fields":{"slug":"/post/2021-11-10-정적-메소드-팩토리/"},"frontmatter":{"categories":"프로그래밍","title":"정적 메소드 팩토리 사용","date":"November 10, 2021"}},"next":{"fields":{"slug":"/post/2021-11-09-method-naming-conventions/"}},"previous":{"fields":{"slug":"/java/2021-11-12-builder-pattern/"}}},{"node":{"id":"9ee058ec-8bd5-5bb0-ac9c-cffb704c4254","excerpt":"of 와 from 의미가 뭘까? 문득 코딩을 하다 궁금해졌습니다. 메소드의 이름으로 사용되는 of 와 from 의 의미에 대해서 알고 싶어졌습니다. 구글 검색결과 oracle - java documentation stackoverflow 등등 에서 정보를 찾을 수 있었습니다. 오라글 문서에서 정의하는 메소드 네이밍 컨벤션은 아래와 같습니다. Prefix Method Type Use of static factory 팩토리가 주로 입력 매개변수의 유효성을 검사하고 변환하지 않는 인스턴스를 만듭니다. from static factory 입력 매개변수를 대상 클래스의 인스턴스로 변환합니다. 이 경우 입력에서 정보가 손실될 수 있습니다. parse static factory 입력 문자열을 구문 분석하여 대상 클래스의 인스턴스를 생성합니다. format instance 지정된 포맷터를 사용하여 임시 개체의 값을 형식화하여 문자열을 생성합니다. get instance 대상 객체 상태의 일부를 …","fields":{"slug":"/post/2021-11-09-method-naming-conventions/"},"frontmatter":{"categories":"프로그래밍","title":"method naming 에서 of 와 from 의 차이는 뭘까?","date":"November 09, 2021"}},"next":{"fields":{"slug":"/java/2021-11-05-collections-unmodifiableList/"}},"previous":{"fields":{"slug":"/post/2021-11-10-정적-메소드-팩토리/"}}},{"node":{"id":"5ccac919-8ba0-504a-b3b4-848d167ff14e","excerpt":"위 코드 출력 결과  는  입니다. Collections.unmodifiableList 으로 반환된 객체는 결국 원본객체의 참조입니다. 그러므로 원본 객체가 수정되면  으로 반횐된 도 동일한 값을 가집니다. 그러나, 는 불변객체 이므로 수정 삭제가 불가능합니다.","fields":{"slug":"/java/2021-11-05-collections-unmodifiableList/"},"frontmatter":{"categories":"프로그래밍","title":"Java - Collections.unmodifiableList 알아보기","date":"November 05, 2021"}},"next":{"fields":{"slug":"/java/2021-11-08-JUnit -Parameterized-test/"}},"previous":{"fields":{"slug":"/post/2021-11-09-method-naming-conventions/"}}},{"node":{"id":"213bc46d-65d7-596f-b645-a346607e3b37","excerpt":"로 다양하게 테스트 해보기  다양한 파라미터로 테스트 할때 유용하게 사용됩니다. 5보다 작은 숫자 테스트 위 코드 처럼 6이하의 케이스를 테스트 하고싶다고 할때, 중복된 코드가 많이 발생하게 됩니다. 이러한 부분을  을 사용해서 리팩토링 해보겠습니다.  를 활용해서 테스트가 진행될때 숫차적으로  인자로 부여되면서 진행됩니다.  이 외에도  등 다른타입도 적용가능합니다. 한개 이상의 인자를 사용하고 싶을때? 위 예제는 5보다 작은 숫자 테스트 였습니다. 그런데 {숫자}보다 작은 숫자 테스트 하고싶을때는 아래와 같은 방법을 사용 할 수 있습니다.  의 기본 구분자는 입니다.\n만약 다른 구분자를 사용하고 싶을때는  를 통해 다른 구분자를 사용해서 분리 시킬수 있습니다. Primitive type 타입 외 객체 부여하기  을 사용하면 다양하게 인자를 사용할 수 있습니다.  메소드처럼 인자를 정의하고  를 통해 메소드 이름을 정의하면,\nPrimitive type 말고도 다양하게 테스트 할 …","fields":{"slug":"/java/2021-11-08-JUnit -Parameterized-test/"},"frontmatter":{"categories":"프로그래밍","title":"JUnit - Parameterized Test","date":"November 05, 2021"}},"next":{"fields":{"slug":"/java/2021-11-05-java-enum/"}},"previous":{"fields":{"slug":"/java/2021-11-05-collections-unmodifiableList/"}}},{"node":{"id":"d9a21c71-26ca-5f12-a18f-d597ef718254","excerpt":"Java Enum 활용기 참고하여 작성되었습니다. 자바 이넘 자비 enum 을 활용하면 상태와 행위를 한곳에서 관리할 수 있는 장점에 대해서 알아 보겠습니다. 예시로 로또 상금 로직 구현해보면서 파악해보겠습니다.\n우선 Enum 미적용된 코드부터 살펴 보겠습니다. Enum 으로 적용안되었을 경우  클래스는 맞춘 로또 숫자에 따라 상금을 반환해주는  메소드를 가지고 있습니다. 우선 위 코드는 확장성에 취약한 상태입니다. 만약에 4등의 상금이 줘야하는 추가 요구상황이 주어졌다면 어떻게 될까요? 이처럼 상태와 로직을 각각 수정해주어야 합니다.  클래스의 인스턴스 변수와 메소드가 같이 있어서 그나마 나아보일 수도 있지만, 위 예제는 단순한 예제이고 복잡해질 경우 유지보수와 확장성에서 어려움을 격을 수 있습니다. Enum 을 활용한다면 어떻게 될까요? 테스트 코드 위 Enum 에도 4등이 빠져 있습니다. 4등을 추가 해주고 싶다면 위 코드만 추가해주면 확장 할 수 있습니다.\n이는 상태와 로직…","fields":{"slug":"/java/2021-11-05-java-enum/"},"frontmatter":{"categories":"프로그래밍","title":"java - ENUM(상태와 행위를 한곳에서 관리)","date":"November 05, 2021"}},"next":{"fields":{"slug":"/java/2021-11-01-what-is-Iterator/"}},"previous":{"fields":{"slug":"/java/2021-11-08-JUnit -Parameterized-test/"}}},{"node":{"id":"b5a81a84-034f-588d-8c70-c0888a155e57","excerpt":"#이터레이터(Iterator) 란? 반복자(iterator)는 객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료 구조의 내부의 요소를 순회(traversing)하는 객체이다.\n(위키백과) Iterator 는 컬렉션 프레임워크에 속하는 인터페이스입니다. 컬렉션을 탐색하고 데이터 요소에 액세스하며 컬렉션의 데이터 요소를 제거할 수 있습니다. Iterator 메소드 Iterator.hasNext() : 다음 요소가 있으면 true 를 반환 Iterator.next() : 다음 요소를 반환 Iterator.remove() : 현재 요소를 제거 example code Iterator 를 잘 활용하면 코드를 단순화하고 일반화 할 수 있을 것 같다.","fields":{"slug":"/java/2021-11-01-what-is-Iterator/"},"frontmatter":{"categories":"프로그래밍","title":"Iterator?","date":"November 02, 2021"}},"next":{"fields":{"slug":"/oop/2021-10-31-object-calisthenics-summary/"}},"previous":{"fields":{"slug":"/java/2021-11-05-java-enum/"}}},{"node":{"id":"0a6a326c-4f31-5972-8bea-d32934ce1423","excerpt":"객체지향 생활 체조 총정리 규칙 1: 한 메서드에 오직 한 단계의 들여쓰기만 한다. 규칙 2: else 예약어를 쓰지 않는다. 규칙 3: 모든 원시값과 문자열을 포장한다. 규칙 4: 한 줄에 점을 하나만 찍는다. 규칙 5: 줄여쓰지 않는다(축약 금지). 규칙 6: 모든 엔티티를 작게 유지한다. 규칙 7: 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다. 규칙 8: 일급 콜렉션을 쓴다. 규칙 9: 게터/세터/프로퍼티를 쓰지 않는다. (developerFarm 개발자 농장 포스팅 내용) 객체지향 생활 체조 9가지의 원칙은 어떻게 보면 당연하거나, 까다롭게 느껴질 수 있다.\n모든 경우에 적용 할 수는 없겠지만 9가지 규칙이 몸에 베인다면 깔끔하고 일관된 코드를 작성 할 수 있을 것 같다.\n규칙을 지키며 작은 프로젝트를 진행 해보았는데. 프로젝트 전반적으로 객체지향,클린코드,리팩토링 측면에서 많은 도움이 되었다.\n 만 지키더라도 코드의 가독성이 많이 향상 된다는 것을 느꼈다.","fields":{"slug":"/oop/2021-10-31-object-calisthenics-summary/"},"frontmatter":{"categories":"프로그래밍","title":"객체지향 생활 체조","date":"November 01, 2021"}},"next":{"fields":{"slug":"/oop/2021-11-03-object-calisthenics-summary-object-wrap/"}},"previous":{"fields":{"slug":"/java/2021-11-01-what-is-Iterator/"}}},{"node":{"id":"0c5b37b3-e650-580c-a45a-76bcb56af28a","excerpt":"Balls 는 ball 리스트를 가집니다. ball 은 최소(MIN), 최대(MAX) 조건이 있는 타입입니다. balls 는 특정한 조건을 가지기 때문에 위 코드 처럼 별도의 검증처리를 해줍니다.  단순히 변수의 이름 “balls” 로 정의 된것이 아닌 좀더 객체지향의 관점에서 본다면 어떨까요?  이렇게 말입니다.  에서  정의 했을 뿐인데, 편안함이 느껴지지 않나요? ^^?;;;;; 는 단순히 Integer 를 가진 변수일까? 어떤 조건이 있는 것 일까? 코드를 처음 보는 사람은 고민을 하게 됩니다. 만약에 객체가 1000줄 짜리 코드이고 거기에  인스턴스 변수였다면, 수정하거나 값을 추가하기 부담스러울 것입니다. validation 하는 부분을 찾기 힘들거나 찾았다 하더라도 정말 그것만으로 다 인가? 하는 의구심이 들기 때문입니다. 어떠한 객체가 있는데 그 객체가 최소(MIN), 최대(MAX) 조건이 있는 타입의 객체라면 어떨까요? Ball.class 로 원시 값 포장을 해보았…","fields":{"slug":"/oop/2021-11-03-object-calisthenics-summary-object-wrap/"},"frontmatter":{"categories":"프로그래밍","title":"객체지향 생활 체조(모든 원시값과 문자열을 포장한다.)","date":"November 01, 2021"}},"next":{"fields":{"slug":"/oop/2021-10-30-oop-capsule-demeter/"}},"previous":{"fields":{"slug":"/oop/2021-10-31-object-calisthenics-summary/"}}},{"node":{"id":"0ee9f0b1-cd40-52aa-992e-e980f16678de","excerpt":"캡슐화 객체의 속성(data fields)와 행위(메서드)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다. (위키피디아) 디미터 법칙(Law of Demeter) 각 유닛은 다른 유닛에 대한 제한된 지식만 가지고 있어야 합니다. 현재 유닛과 “밀접하게” 관련된 유닛만 있어야 합니다. 각 유닛은 친구들과만 대화해야 합니다. 낯선 사람과 이야기하지 마십시오. 가까운 친구에게만 이야기하십시오. (위키피디아) 캡슐화는 외부로부터 내부 로직을 감춤으로써(은닉), 객체의 내부 데이터와 메소드의 응집도가 생깁니다. 이러한 부분은 스스로 자율적인 객체가 되는 이점이있습니다.\n프로젝트가 커지거나 유지보수를 해야할때 추가 또는 수정되는 코드의 비용을 줄일 수 있습니다.\n또한, 데이터와 메소드의 응집도가 생기므로 팀단위 개발 또는 규모가 커질때 파편화된 코드를 줄일 수 있고 중복된 코드를 방지 할 수있습니다. 캡슐화를 적용하지 않은 코드 예시 MemberTest 에서 으로 Role 에…","fields":{"slug":"/oop/2021-10-30-oop-capsule-demeter/"},"frontmatter":{"categories":"프로그래밍","title":"객체지향 - 캡슐화 , 디미터법칙","date":"October 30, 2021"}},"next":{"fields":{"slug":"/kafka/2021-03-14-kafka-connect-action/"}},"previous":{"fields":{"slug":"/oop/2021-11-03-object-calisthenics-summary-object-wrap/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}